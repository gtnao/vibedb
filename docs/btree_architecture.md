# B+Treeインデックスアーキテクチャ

## 概要

vibedbのB+Treeインデックスは、効率的な範囲検索と並行制御をサポートする、ディスクベースのインデックス構造です。本実装は、教科書的なB+Treeアルゴリズムに加え、実用的なRDBMSで必要とされる高度な並行制御機構（ラッチカップリング）を備えています。

## 主要コンポーネント

### ストレージ層（storage/page/）
- **btree_internal_page.rs**: 内部ノードページの実装
  - キーと子ページポインタを管理
  - 可変長キーのサポート
  - ページ分割・マージのロジック
  
- **btree_leaf_page.rs**: リーフノードページの実装
  - キーとTupleIdのペアを管理
  - 兄弟ポインタによる連結リスト構造
  - 重複キーのサポート

### アクセス層（access/）
- **btree.rs**: B+Tree本体の実装
  - 挿入、削除、検索の高レベルAPI
  - ラッチカップリングプロトコルの実装
  - ルートページの管理
  
- **btree/key.rs**: キーの抽象化
  - 複合キーのサポート
  - 型安全な比較演算
  - シリアライゼーション
  
- **btree/latch.rs**: ラッチ管理
  - ページレベルのReader-Writerラッチ
  - デッドロック検出
  - ラッチ統計情報
  
- **btree/iterator.rs**: 範囲スキャンイテレータ
  - 効率的な範囲検索
  - 兄弟ポインタを使った順次アクセス
  - ラッチを考慮した並行制御

## ページ構造

### 内部ノードページレイアウト（8KB）

```
+------------------------+
| Header (24 bytes)      |
| - page_type: u8        |
| - lower: u16           |
| - upper: u16           |
| - parent_page_id: u32  |
| - page_id: u32         |
| - level: u16           |
| - key_count: u16       |
| - reserved: [u8; 5]    |
+------------------------+
| Slot Array             |
| [Slot; N]              |
| Slot = {               |
|   child_page_id: u32   |
|   key_offset: u16      |
|   key_length: u16      |
| } (8 bytes each)       |
+------------------------+
| Free Space             |
| (lower to upper)       |
+------------------------+
| Key Data Area          |
| (Variable length keys) |
| (Grows from end)       |
+------------------------+
| Right Child PageId     |
| (4 bytes at end)       |
+------------------------+
```

**設計の要点**：
- heap pageと同じlower/upper方式でスロット配列とデータ領域を管理
- キー数Nに対して、子ポインタはN+1個存在（最後の子は別途保存）
- スロット配列はヘッダー直後から成長（lower）
- キーデータはページ末尾から前方に向かって成長（upper）
- 空き領域は動的に計算：`upper - lower`
- 最大キー数は動的に決定（キーサイズに依存）

### リーフノードページレイアウト（8KB）

```
+------------------------+
| Header (32 bytes)      |
| - page_type: u8        |
| - lower: u16           |
| - upper: u16           |
| - parent_page_id: u32  |
| - page_id: u32         |
| - next_page_id: u32    |
| - prev_page_id: u32    |
| - key_count: u16       |
| - reserved: [u8; 7]    |
+------------------------+
| Slot Array             |
| [Slot; N]              |
| Slot = {               |
|   key_offset: u16      |
|   key_length: u16      |
|   tuple_id: TupleId    |
| } (10 bytes each)      |
+------------------------+
| Free Space             |
| (lower to upper)       |
+------------------------+
| Key Data Area          |
| (Variable length keys) |
| (Grows from end)       |
+------------------------+
```

**設計の要点**：
- heap pageと同じlower/upper方式でスロット配列とデータ領域を管理
- 各エントリはキーとTupleIdのペア
- スロット配列にTupleIdを直接格納（固定長6バイト）
- 兄弟ポインタ（next/prev）により双方向連結リスト形成
- 範囲スキャンは兄弟ポインタを辿ることで効率化
- リーフレベルが実際のデータ（TupleId）を保持

## キー設計

### 複合キーのサポート

B+Treeは複数カラムからなる複合キーをサポートします：

```rust
// 例：(user_id, timestamp)の複合インデックス
let schema = vec![DataType::Int32, DataType::Int64];
let key = BTreeKey::from_values(&[
    Value::Int32(100),
    Value::Int64(1234567890),
], &schema)?;
```

### キーの比較規則

1. **NULL値の扱い**
   - NULLは最小値として扱う（PostgreSQL方式）
   - NULL < 任意の非NULL値
   
2. **複合キーの比較**
   - 左から右へ辞書順で比較
   - 最初に異なる要素で大小を決定
   
3. **重複キーの扱い**
   - 同一キーに対して複数のTupleIdを許可
   - (user_key, tuple_id)の組み合わせで一意性を保証
   - 範囲検索時は全ての重複エントリを返す

### キーのシリアライゼーション

```
+-------------------+
| Key Length (2B)   |
+-------------------+
| Column Count (2B) |
+-------------------+
| Column 1 Type (1B)|
+-------------------+
| Column 1 Data     |
| (Variable)        |
+-------------------+
| Column 2 Type (1B)|
+-------------------+
| Column 2 Data     |
| (Variable)        |
+-------------------+
| ...               |
+-------------------+
```

## ページ分割とマージ

### 分割（Split）戦略

1. **リーフノードの分割**
   - ページが満杯になったら中央で分割
   - 右半分を新しいページに移動
   - 兄弟ポインタを更新
   - 親に中間キーを挿入

2. **内部ノードの分割**
   - 同様に中央で分割
   - 分割が再帰的に上方へ伝播
   - ルート分割時は新しいルートを作成

### マージ戦略

1. **アンダーフロー条件**
   - キー数が最小値（capacity/2）を下回る
   
2. **再分配の試行**
   - 隣接兄弟からキーを借りる
   - マージを回避してパフォーマンス向上
   
3. **マージの実行**
   - 再分配が不可能な場合にマージ
   - 右兄弟を優先的に選択
   - 親からセパレータキーを削除

## メモリ管理とバッファプール統合

### ページのライフサイクル

1. **ページの取得**
   ```rust
   let guard = buffer_pool.fetch_page_write(page_id)?;
   let btree_page = BTreeInternalPage::from_data(&mut guard);
   ```

2. **ページの作成**
   ```rust
   let (page_id, mut guard) = buffer_pool.new_page()?;
   let btree_page = BTreeLeafPage::new(&mut guard, parent_id);
   ```

3. **ページの解放**
   - Rustの`Drop`トレイトにより自動的に解放
   - ダーティフラグは自動的に設定

### キャッシュ効率の考慮

- 頻繁にアクセスされるルート付近のページは自然にキャッシュに残る
- LRU置換により、使用頻度の低いページから退避
- ラッチ保持中はページが退避されない保証

## エラー処理とリカバリ

### エラーの種類

1. **構造的エラー**
   - ページ容量超過
   - 不正なキー順序
   - 破損したページヘッダー

2. **並行制御エラー**
   - デッドロック
   - ラッチタイムアウト

3. **I/Oエラー**
   - ディスク読み書き失敗
   - ページ割り当て失敗

### リカバリ機構

- Write-Ahead Logging (WAL)との統合（将来実装）
- ページレベルのチェックサム（将来実装）
- 部分的な操作のロールバック

## パフォーマンス特性

### 時間計算量
- 検索: O(log N)
- 挿入: O(log N)
- 削除: O(log N)
- 範囲検索: O(log N + K) ※Kは結果数

### 空間効率
- 各ノードは最低50%の使用率を保証（ルートを除く）
- 平均的な使用率は約69%（理論値）

### 並行性
- 複数の読み取りトランザクションが同時実行可能
- 書き込みは影響を受けるパスのみをロック
- ラッチカップリングにより並行性を最大化